# Adafruit Motor Shield v2 Driver for Linux
This is a Linux port of the Adafruit Motor Shield v2 driver for Arduino. The port maintains
parity with the Adafruit implementation, and extends it to provide more useful features.
Check out `examples/motorshield.cpp` to understand basic usage. The library is also extensively
documented, and a doxygen documentation can be generated by executing `make doc`. To build and
test, execute `make`, preferably on a Raspberry Pi, and execute `motor.out` that is generated.
The example here initializes the connected motor shield at the default I2C bus and address, initializes a stepper motor at port 2, and actuates it.

The example starts operation by initializing the motor shield:
```c
    Adafruit::MotorShield AFMS; // create an Adafruit::MotorShield object with at bus 1, device 0x60
    AFMS.begin(); // initialize the motor shield
```
At this point a stepper motor (or a DC motor) can be obtained:
```c
    Adafruit::StepperMotor *motor = AFMS.getStepper(200, 2, Adafruit::MicroSteps::STEP16);
```
The stepper motor is initialized on port 2, does 200 steps per revolution, and has 16 microsteps per step. At 16 microsteps, the motor can be driven at ~5 rpm max in microstepping mode.
After obtaining the motor, the speed of rotation needs to be set:
```c
    motor->setSpeed(1); // sets speed to 1 RPM
```
The `setSpeed()` method sets the desired speed of the motor, in this instance to 1 RPM.
Now the motor can be stepped by the desired number of steps using the `step()` function:
```c
    motor->step(200, Adafruit::MotorDir::FORWARD, Adafruit::MotorStyle::MICROSTEP);
```
The motor, here, is requested to perform 200 steps in the 'forward' direction using microstepping to produce a smooth motion. Note: Using `Adafruit::MotorStyle::SINGLE` or `Adafruit::MotorStyle::DOUBLE`, as applicable for the stepper motor in question, would allow a maximum speed of approximately 68 RPM at the expense of jerky motion.
Stepper motors, when not moving, have their coils energized to provide stall torque. If stall torque is not required, the motor can be released to reduce power consumption:
```c
    motor->release();
```
Exiting the program automatically releases the motor.